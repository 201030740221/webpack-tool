// Generated by CoffeeScript 1.9.3
(function() {
  var DevConfigWebpackPlugin, ExtractCssPlugin, ExtractHtmlPlugin, ManifestWebpackPlugin, assign, cwd, defaultConfig, fs, getLoaders, gutil, path, webpack;

  path = require('path');

  fs = require('fs');

  webpack = require('webpack');

  gutil = require('gulp-util');

  assign = require('object-assign');

  ExtractCssPlugin = require("../plugins/extract-css-webpack-plugin");

  ExtractHtmlPlugin = require("../plugins/extract-html-webpack-plugin");

  ManifestWebpackPlugin = require('../plugins/manifest-webpack-plugin');

  DevConfigWebpackPlugin = require('../plugins/dev-config-webpack-plugin');

  getLoaders = require('../configs/getloaders');

  cwd = process.cwd();

  defaultConfig = require('./default.config.js');

  module.exports = function(opts, mode) {
    var _alias, addVendor, alias_objs, entry, entryType, env, exportCssName, exportJSName, loaders, options, plugins, readPageDir, serverPort, vendor, vendorPath, web_env, webpackConfig;
    if (mode == null) {
      mode = "web-mode";
    }
    loaders = getLoaders(opts);
    serverPort = opts.server && opts.server.devPort;
    env = gutil.env.env || opts.env;
    webpackConfig = assign({}, defaultConfig.webpack.base, opts.webpack.base, opts.webpack[env] ? opts.webpack[env] : defaultConfig.webpack[env]);
    web_env = gutil.env;
    delete web_env["_"];
    assign(opts.config, web_env);
    webpackConfig.output = path.join(cwd, webpackConfig.output);
    webpackConfig.jsPath = path.join(cwd, webpackConfig.jsPath);
    webpackConfig.cssPath = path.join(cwd, webpackConfig.cssPath);
    webpackConfig.htmlPath = path.join(cwd, webpackConfig.htmlPath);
    alias_objs = {};
    for (_alias in webpackConfig.resolve.alias) {
      alias_objs[_alias] = path.join(cwd, webpackConfig.resolve.alias[_alias]);
    }
    webpackConfig.resolve.alias = alias_objs;
    entry = {};
    entryType = ['.js', '.coffee', '.cjsx', '.jsx', '.html', '.styl', '.scss', '.less', '.css'];
    readPageDir = function(subDir) {
      var _ext, dirs, dirsPath, sameName;
      dirs = subDir && subDir.fs;
      dirsPath = subDir && subDir.path;
      _ext = subDir && subDir.ext;
      sameName = false;
      return dirs.forEach(function(item) {
        var _filename, data, devServerJs, ext, name;
        _filename = (subDir && subDir.filename) || item;
        name = (subDir && subDir.name) || item;
        if (fs.statSync(dirsPath + '/' + item).isDirectory() && item.indexOf('_') !== 0) {
          data = {
            name: item,
            path: dirsPath + '/' + item,
            fs: fs.readdirSync(dirsPath + '/' + item),
            filename: (subDir && subDir.filename && subDir.filename + "-" + item) || item,
            ext: _ext
          };
          return readPageDir(data);
        } else if (item.indexOf('_') !== 0 && !sameName) {
          ext = path.extname(dirsPath + '/' + item);
          if (entryType.indexOf(ext) !== -1) {
            devServerJs = ["webpack-dev-server/client?http://0.0.0.0:" + serverPort, 'webpack/hot/only-dev-server'];
            if (name === item.replace(ext, '')) {
              if (entry[_filename]) {
                entry[_filename] = entry[_filename].filter(function(_item, index) {
                  var _item_ext;
                  _item_ext = path.extname(_item);
                  if (_ext === "js" && [".coffee", ".js", ".cjsx", ".jsx"].indexOf(_item_ext) !== -1) {
                    return false;
                  }
                  if (_ext === "css" && [".styl", ".css", ".scss", ".less"].indexOf(_item_ext) !== -1) {
                    return false;
                  }
                  if (_ext === "html" && [".html"].indexOf(_item_ext) !== -1) {
                    return false;
                  }
                  return true;
                });
              } else {
                entry[_filename] = [];
              }
              if (env === "development" && (!opts.server.liveload && opts.webpack.hot) && _ext === "js") {
                entry[_filename].concat(devServerJs);
                entry[_filename].push(dirsPath + '/' + item);
              } else {
                if (_ext === "css" && fs.existsSync(webpackConfig.cssCommonPath)) {
                  entry[_filename].push(webpackConfig.cssCommonPath);
                  entry[_filename].push(dirsPath + '/' + item);
                } else {
                  entry[_filename].push(dirsPath + '/' + item);
                }
              }
              return sameName = true;
            } else {
              if (entry[_filename]) {
                entry[_filename] = entry[_filename];
              } else {
                if (env === "development" && (!opts.server.liveload && opts.webpack.hot) && _ext === "js") {
                  entry[_filename] = devServerJs;
                } else {
                  entry[_filename] = [];
                }
              }
              return entry[_filename].push(dirsPath + '/' + item);
            }
          }
        }
      });
    };
    if (webpackConfig.exportCss && fs.existsSync(webpackConfig.cssPath)) {
      readPageDir({
        ext: "css",
        path: webpackConfig.cssPath,
        htmlPath: webpackConfig.htmlPath,
        cssPath: webpackConfig.cssPath,
        fs: fs.readdirSync(webpackConfig.cssPath)
      });
    }
    if (webpackConfig.exportHtml && fs.existsSync(webpackConfig.htmlPath)) {
      readPageDir({
        ext: "html",
        path: webpackConfig.htmlPath,
        htmlPath: webpackConfig.htmlPath,
        cssPath: webpackConfig.cssPath,
        fs: fs.readdirSync(webpackConfig.htmlPath)
      });
    }
    if (webpackConfig.jsPath && fs.existsSync(webpackConfig.jsPath)) {
      readPageDir({
        ext: "js",
        path: webpackConfig.jsPath,
        htmlPath: webpackConfig.htmlPath,
        cssPath: webpackConfig.cssPath,
        fs: fs.readdirSync(webpackConfig.jsPath)
      });
    }
    plugins = [];
    if (webpackConfig.commonFiles) {
      plugins.push(new webpack.optimize.CommonsChunkPlugin({
        chunks: entry,
        name: "common",
        minChunks: 2
      }));
    }
    if (webpackConfig.global) {
      plugins.push(new webpack.ProvidePlugin(webpackConfig.global));
    }
    if (env === "development") {
      plugins.push(new webpack.DefinePlugin({
        __DEV__: true,
        __QA__: false,
        __PRO__: false
      }));
    }
    if (env === "qa") {
      plugins.push(new webpack.DefinePlugin({
        __DEV__: false,
        __QA__: true,
        __PRO__: false
      }));
    }
    if (env === "production") {
      plugins.push(new webpack.DefinePlugin({
        "process.env": {
          NODE_ENV: JSON.stringify("production")
        },
        __DEV__: false,
        __QA__: false,
        __PRO__: true
      }));
      plugins.push(new webpack.HotModuleReplacementPlugin());
    }
    if (webpackConfig.exportCss) {
      exportCssName = webpackConfig.hash ? "css/[name].[hash].css" : "css/[name].css";
      plugins.push(new ExtractCssPlugin(exportCssName));
    }
    if (webpackConfig.exportHtml) {
      plugins.push(new ExtractHtmlPlugin("[name].html", {
        chunksEntry: entry
      }));
    }
    if (webpackConfig.uglify) {
      plugins.push(new webpack.optimize.UglifyJsPlugin({
        compress: {
          warnings: false
        }
      }));
    }
    if (webpackConfig.map && mode === "web-mode") {
      plugins.push(new ManifestWebpackPlugin(path.join(webpackConfig.output, 'map.json')));
    }
    if (mode === "web-mode" && webpackConfig.configFile) {
      DevConfigWebpackPlugin(path.join(webpackConfig.output, 'config.js'), opts.config);
    }
    exportJSName = webpackConfig.hash ? "js/[name].[hash].js" : "js/[name].js";
    options = {
      entry: entry,
      recursive: !!(env === "production"),
      cache: !!(env === "production"),
      debug: !!(env === "production"),
      output: {
        path: webpackConfig.output,
        filename: exportJSName,
        publicPath: webpackConfig.cdn ? opts.cdnPath : opts.server.publicPath,
        sourceMapFilename: "[file].map"
      },
      resolveLoader: {
        modulesDirectories: ['node_modules']
      },
      plugins: plugins,
      resolve: {
        extensions: ['', '.js', '.jsx', '.cjsx', '.coffee']
      },
      module: {
        loaders: loaders,
        noParse: []
      }
    };
    if (webpackConfig.webpackDebug) {
      options = assign(options, {
        profile: true,
        stats: {
          reasons: true,
          exclude: [],
          modules: true,
          colors: true
        }
      });
    }
    if (webpackConfig.sourceMap) {
      options = assign(options, {
        devtool: "source-map"
      });
    }
    options.resolve = webpackConfig.resolve;
    options.externals = webpackConfig.externals;
    addVendor = function(name, path) {
      options.resolve.alias[name] = path;
      return options.module.noParse.push(new RegExp('^' + name + '$'));
    };
    for (vendor in webpackConfig.vendorlist) {
      vendorPath = webpackConfig.vendorlist[vendor];
      if (!(/^(http?:)?\/\//.test(path))) {
        vendorPath = path.join(cwd, vendorPath);
      }
      addVendor(vendor, vendorPath);
    }
    return assign({}, options);
  };

}).call(this);
